/*
 * generated by Xtext 2.27.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.AdvancedVariable;
import org.xtext.example.mydsl.myDsl.And;
import org.xtext.example.mydsl.myDsl.AtomicExpressionDate;
import org.xtext.example.mydsl.myDsl.AtomicExpressionDouble;
import org.xtext.example.mydsl.myDsl.AtomicExpressionEnum;
import org.xtext.example.mydsl.myDsl.AtomicExpressionFalse;
import org.xtext.example.mydsl.myDsl.AtomicExpressionInt;
import org.xtext.example.mydsl.myDsl.AtomicExpressionParameter;
import org.xtext.example.mydsl.myDsl.AtomicExpressionString;
import org.xtext.example.mydsl.myDsl.AtomicExpressionTrue;
import org.xtext.example.mydsl.myDsl.Clause;
import org.xtext.example.mydsl.myDsl.ClauseBody;
import org.xtext.example.mydsl.myDsl.ClauseParameter;
import org.xtext.example.mydsl.myDsl.Command;
import org.xtext.example.mydsl.myDsl.Comparison;
import org.xtext.example.mydsl.myDsl.Condition;
import org.xtext.example.mydsl.myDsl.Constraint;
import org.xtext.example.mydsl.myDsl.Contract;
import org.xtext.example.mydsl.myDsl.ContractEvent;
import org.xtext.example.mydsl.myDsl.ContractState;
import org.xtext.example.mydsl.myDsl.Declaration;
import org.xtext.example.mydsl.myDsl.Div;
import org.xtext.example.mydsl.myDsl.Entities;
import org.xtext.example.mydsl.myDsl.Entity;
import org.xtext.example.mydsl.myDsl.EntityDeclaration;
import org.xtext.example.mydsl.myDsl.EntityDeclarationParam;
import org.xtext.example.mydsl.myDsl.EntityType;
import org.xtext.example.mydsl.myDsl.EnumEntity;
import org.xtext.example.mydsl.myDsl.EnumMember;
import org.xtext.example.mydsl.myDsl.Equality;
import org.xtext.example.mydsl.myDsl.Interval;
import org.xtext.example.mydsl.myDsl.IntervalFunction;
import org.xtext.example.mydsl.myDsl.Logic;
import org.xtext.example.mydsl.myDsl.Minus;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.Multi;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.NegatedPAtom;
import org.xtext.example.mydsl.myDsl.NegatedPrimaryExpression;
import org.xtext.example.mydsl.myDsl.Obligation;
import org.xtext.example.mydsl.myDsl.ObligationEvent;
import org.xtext.example.mydsl.myDsl.ObligationState;
import org.xtext.example.mydsl.myDsl.ObligationWrapper;
import org.xtext.example.mydsl.myDsl.OneArgMathFunction;
import org.xtext.example.mydsl.myDsl.OneArgStringFunction;
import org.xtext.example.mydsl.myDsl.Or;
import org.xtext.example.mydsl.myDsl.OtherDeclaration;
import org.xtext.example.mydsl.myDsl.PAnd;
import org.xtext.example.mydsl.myDsl.PAtomDateLiteral;
import org.xtext.example.mydsl.myDsl.PAtomDoubleLiteral;
import org.xtext.example.mydsl.myDsl.PAtomEnum;
import org.xtext.example.mydsl.myDsl.PAtomFunction;
import org.xtext.example.mydsl.myDsl.PAtomIntLiteral;
import org.xtext.example.mydsl.myDsl.PAtomPredicate;
import org.xtext.example.mydsl.myDsl.PAtomPredicateFalseLiteral;
import org.xtext.example.mydsl.myDsl.PAtomPredicateTrueLiteral;
import org.xtext.example.mydsl.myDsl.PAtomRecursive;
import org.xtext.example.mydsl.myDsl.PAtomStringLiteral;
import org.xtext.example.mydsl.myDsl.PAtomVariable;
import org.xtext.example.mydsl.myDsl.PComparison;
import org.xtext.example.mydsl.myDsl.PEquality;
import org.xtext.example.mydsl.myDsl.PFContractResumed;
import org.xtext.example.mydsl.myDsl.PFContractSuspended;
import org.xtext.example.mydsl.myDsl.PFContractTerminated;
import org.xtext.example.mydsl.myDsl.PFObligationDischarged;
import org.xtext.example.mydsl.myDsl.PFObligationResumed;
import org.xtext.example.mydsl.myDsl.PFObligationSuspended;
import org.xtext.example.mydsl.myDsl.PFObligationTerminated;
import org.xtext.example.mydsl.myDsl.PFObligationTriggered;
import org.xtext.example.mydsl.myDsl.POr;
import org.xtext.example.mydsl.myDsl.Plus;
import org.xtext.example.mydsl.myDsl.Point;
import org.xtext.example.mydsl.myDsl.PointAtomContractEvent;
import org.xtext.example.mydsl.myDsl.PointAtomObligationEvent;
import org.xtext.example.mydsl.myDsl.PointAtomParameterDotExpression;
import org.xtext.example.mydsl.myDsl.PointAtomPowerEvent;
import org.xtext.example.mydsl.myDsl.PointFunction;
import org.xtext.example.mydsl.myDsl.Power;
import org.xtext.example.mydsl.myDsl.PowerEvent;
import org.xtext.example.mydsl.myDsl.PowerState;
import org.xtext.example.mydsl.myDsl.PowerWrapper;
import org.xtext.example.mydsl.myDsl.PredicateFunctionCannotBeAssigned;
import org.xtext.example.mydsl.myDsl.PredicateFunctionHappens;
import org.xtext.example.mydsl.myDsl.PredicateFunctionHappensAfter;
import org.xtext.example.mydsl.myDsl.PredicateFunctionHappensWithin;
import org.xtext.example.mydsl.myDsl.PredicateFunctionIsEqual;
import org.xtext.example.mydsl.myDsl.PredicateFunctionIsOwner;
import org.xtext.example.mydsl.myDsl.PredicateFunctionOccurs;
import org.xtext.example.mydsl.myDsl.PredicateFunctionSHappensBefore;
import org.xtext.example.mydsl.myDsl.PredicateFunctionSHappensBeforeEvent;
import org.xtext.example.mydsl.myDsl.PredicateFunctionWHappensBefore;
import org.xtext.example.mydsl.myDsl.PredicateFunctionWHappensBeforeEvent;
import org.xtext.example.mydsl.myDsl.PrimaryExpressionFunctionCall;
import org.xtext.example.mydsl.myDsl.PrimaryExpressionRecursive;
import org.xtext.example.mydsl.myDsl.Primitive;
import org.xtext.example.mydsl.myDsl.PrimitiveVariable;
import org.xtext.example.mydsl.myDsl.SituationExpression;
import org.xtext.example.mydsl.myDsl.ThreeArgDateFunction;
import org.xtext.example.mydsl.myDsl.ThreeArgStringFunction;
import org.xtext.example.mydsl.myDsl.TimevalueInt;
import org.xtext.example.mydsl.myDsl.TimevalueVariable;
import org.xtext.example.mydsl.myDsl.TwoArgMathFunction;
import org.xtext.example.mydsl.myDsl.TwoArgStringFunction;
import org.xtext.example.mydsl.myDsl.VariableDotExpression;
import org.xtext.example.mydsl.myDsl.VariableEvent;
import org.xtext.example.mydsl.myDsl.VariableRef;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ADVANCED_VARIABLE:
				sequence_AdvancedVariable(context, (AdvancedVariable) semanticObject); 
				return; 
			case MyDslPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_DATE:
				sequence_AtomicExpression(context, (AtomicExpressionDate) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_DOUBLE:
				sequence_AtomicExpression(context, (AtomicExpressionDouble) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_ENUM:
				sequence_AtomicExpression(context, (AtomicExpressionEnum) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_FALSE:
				sequence_AtomicExpression(context, (AtomicExpressionFalse) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_INT:
				sequence_AtomicExpression(context, (AtomicExpressionInt) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_PARAMETER:
				sequence_AtomicExpression(context, (AtomicExpressionParameter) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_STRING:
				sequence_AtomicExpression(context, (AtomicExpressionString) semanticObject); 
				return; 
			case MyDslPackage.ATOMIC_EXPRESSION_TRUE:
				sequence_AtomicExpression(context, (AtomicExpressionTrue) semanticObject); 
				return; 
			case MyDslPackage.CLAUSE:
				sequence_Clause(context, (Clause) semanticObject); 
				return; 
			case MyDslPackage.CLAUSE_BODY:
				sequence_ClauseBody(context, (ClauseBody) semanticObject); 
				return; 
			case MyDslPackage.CLAUSE_PARAMETER:
				sequence_ClauseParameter(context, (ClauseParameter) semanticObject); 
				return; 
			case MyDslPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case MyDslPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case MyDslPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MyDslPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case MyDslPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case MyDslPackage.CONTRACT_EVENT:
				sequence_ContractEvent(context, (ContractEvent) semanticObject); 
				return; 
			case MyDslPackage.CONTRACT_STATE:
				sequence_ContractState(context, (ContractState) semanticObject); 
				return; 
			case MyDslPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case MyDslPackage.DIV:
				sequence_Multiplication(context, (Div) semanticObject); 
				return; 
			case MyDslPackage.ENTITIES:
				sequence_Entities(context, (Entities) semanticObject); 
				return; 
			case MyDslPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case MyDslPackage.ENTITY_DECLARATION:
				sequence_EntityDeclaration(context, (EntityDeclaration) semanticObject); 
				return; 
			case MyDslPackage.ENTITY_DECLARATION_PARAM:
				sequence_EntityDeclarationParam(context, (EntityDeclarationParam) semanticObject); 
				return; 
			case MyDslPackage.ENTITY_TYPE:
				sequence_EntityType(context, (EntityType) semanticObject); 
				return; 
			case MyDslPackage.ENUM_ENTITY:
				sequence_EnumEntity(context, (EnumEntity) semanticObject); 
				return; 
			case MyDslPackage.ENUM_MEMBER:
				sequence_EnumMember(context, (EnumMember) semanticObject); 
				return; 
			case MyDslPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case MyDslPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case MyDslPackage.INTERVAL_FUNCTION:
				sequence_IntervalExpression(context, (IntervalFunction) semanticObject); 
				return; 
			case MyDslPackage.LOGIC:
				sequence_Logic(context, (Logic) semanticObject); 
				return; 
			case MyDslPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.MULTI:
				sequence_Multiplication(context, (Multi) semanticObject); 
				return; 
			case MyDslPackage.NEGATED_PATOM:
				sequence_PAtomicExpression(context, (NegatedPAtom) semanticObject); 
				return; 
			case MyDslPackage.NEGATED_PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (NegatedPrimaryExpression) semanticObject); 
				return; 
			case MyDslPackage.OBLIGATION:
				sequence_Obligation(context, (Obligation) semanticObject); 
				return; 
			case MyDslPackage.OBLIGATION_EVENT:
				sequence_ObligationEvent(context, (ObligationEvent) semanticObject); 
				return; 
			case MyDslPackage.OBLIGATION_STATE:
				sequence_ObligationState(context, (ObligationState) semanticObject); 
				return; 
			case MyDslPackage.OBLIGATION_WRAPPER:
				sequence_ObligationWrapper(context, (ObligationWrapper) semanticObject); 
				return; 
			case MyDslPackage.ONE_ARG_MATH_FUNCTION:
				sequence_MathFunction(context, (OneArgMathFunction) semanticObject); 
				return; 
			case MyDslPackage.ONE_ARG_STRING_FUNCTION:
				sequence_StringFunction(context, (OneArgStringFunction) semanticObject); 
				return; 
			case MyDslPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case MyDslPackage.OTHER_DECLARATION:
				sequence_OtherDeclaration(context, (OtherDeclaration) semanticObject); 
				return; 
			case MyDslPackage.PAND:
				sequence_PAnd(context, (PAnd) semanticObject); 
				return; 
			case MyDslPackage.PATOM_DATE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomDateLiteral) semanticObject); 
				return; 
			case MyDslPackage.PATOM_DOUBLE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomDoubleLiteral) semanticObject); 
				return; 
			case MyDslPackage.PATOM_ENUM:
				sequence_PAtomicExpression(context, (PAtomEnum) semanticObject); 
				return; 
			case MyDslPackage.PATOM_FUNCTION:
				sequence_PAtomicExpression(context, (PAtomFunction) semanticObject); 
				return; 
			case MyDslPackage.PATOM_INT_LITERAL:
				sequence_PAtomicExpression(context, (PAtomIntLiteral) semanticObject); 
				return; 
			case MyDslPackage.PATOM_PREDICATE:
				sequence_PAtomicExpression(context, (PAtomPredicate) semanticObject); 
				return; 
			case MyDslPackage.PATOM_PREDICATE_FALSE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomPredicateFalseLiteral) semanticObject); 
				return; 
			case MyDslPackage.PATOM_PREDICATE_TRUE_LITERAL:
				sequence_PAtomicExpression(context, (PAtomPredicateTrueLiteral) semanticObject); 
				return; 
			case MyDslPackage.PATOM_RECURSIVE:
				sequence_PAtomicExpression(context, (PAtomRecursive) semanticObject); 
				return; 
			case MyDslPackage.PATOM_STRING_LITERAL:
				sequence_PAtomicExpression(context, (PAtomStringLiteral) semanticObject); 
				return; 
			case MyDslPackage.PATOM_VARIABLE:
				sequence_PAtomicExpression(context, (PAtomVariable) semanticObject); 
				return; 
			case MyDslPackage.PCOMPARISON:
				sequence_PComparison(context, (PComparison) semanticObject); 
				return; 
			case MyDslPackage.PEQUALITY:
				sequence_PEquality(context, (PEquality) semanticObject); 
				return; 
			case MyDslPackage.PF_CONTRACT_RESUMED:
				sequence_PowerFunction(context, (PFContractResumed) semanticObject); 
				return; 
			case MyDslPackage.PF_CONTRACT_SUSPENDED:
				sequence_PowerFunction(context, (PFContractSuspended) semanticObject); 
				return; 
			case MyDslPackage.PF_CONTRACT_TERMINATED:
				sequence_PowerFunction(context, (PFContractTerminated) semanticObject); 
				return; 
			case MyDslPackage.PF_OBLIGATION_DISCHARGED:
				sequence_PowerFunction(context, (PFObligationDischarged) semanticObject); 
				return; 
			case MyDslPackage.PF_OBLIGATION_RESUMED:
				sequence_PowerFunction(context, (PFObligationResumed) semanticObject); 
				return; 
			case MyDslPackage.PF_OBLIGATION_SUSPENDED:
				sequence_PowerFunction(context, (PFObligationSuspended) semanticObject); 
				return; 
			case MyDslPackage.PF_OBLIGATION_TERMINATED:
				sequence_PowerFunction(context, (PFObligationTerminated) semanticObject); 
				return; 
			case MyDslPackage.PF_OBLIGATION_TRIGGERED:
				sequence_PowerFunction(context, (PFObligationTriggered) semanticObject); 
				return; 
			case MyDslPackage.POR:
				sequence_POr(context, (POr) semanticObject); 
				return; 
			case MyDslPackage.PLUS:
				sequence_Addition(context, (Plus) semanticObject); 
				return; 
			case MyDslPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case MyDslPackage.POINT_ATOM_CONTRACT_EVENT:
				sequence_PointAtom(context, (PointAtomContractEvent) semanticObject); 
				return; 
			case MyDslPackage.POINT_ATOM_OBLIGATION_EVENT:
				sequence_PointAtom(context, (PointAtomObligationEvent) semanticObject); 
				return; 
			case MyDslPackage.POINT_ATOM_PARAMETER_DOT_EXPRESSION:
				sequence_PointAtom(context, (PointAtomParameterDotExpression) semanticObject); 
				return; 
			case MyDslPackage.POINT_ATOM_POWER_EVENT:
				sequence_PointAtom(context, (PointAtomPowerEvent) semanticObject); 
				return; 
			case MyDslPackage.POINT_FUNCTION:
				sequence_PointFunction(context, (PointFunction) semanticObject); 
				return; 
			case MyDslPackage.POWER:
				sequence_Power(context, (Power) semanticObject); 
				return; 
			case MyDslPackage.POWER_EVENT:
				sequence_PowerEvent(context, (PowerEvent) semanticObject); 
				return; 
			case MyDslPackage.POWER_STATE:
				sequence_PowerState(context, (PowerState) semanticObject); 
				return; 
			case MyDslPackage.POWER_WRAPPER:
				sequence_PowerWrapper(context, (PowerWrapper) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_CANNOT_BE_ASSIGNED:
				sequence_OtherFunction(context, (PredicateFunctionCannotBeAssigned) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_HAPPENS:
				sequence_PredicateFunction(context, (PredicateFunctionHappens) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_HAPPENS_AFTER:
				sequence_PredicateFunction(context, (PredicateFunctionHappensAfter) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_HAPPENS_WITHIN:
				sequence_PredicateFunction(context, (PredicateFunctionHappensWithin) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_IS_EQUAL:
				sequence_OtherFunction(context, (PredicateFunctionIsEqual) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_IS_OWNER:
				sequence_OtherFunction(context, (PredicateFunctionIsOwner) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_OCCURS:
				sequence_PredicateFunction(context, (PredicateFunctionOccurs) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_SHAPPENS_BEFORE:
				sequence_PredicateFunction(context, (PredicateFunctionSHappensBefore) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT:
				sequence_PredicateFunction(context, (PredicateFunctionSHappensBeforeEvent) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_WHAPPENS_BEFORE:
				sequence_PredicateFunction(context, (PredicateFunctionWHappensBefore) semanticObject); 
				return; 
			case MyDslPackage.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT:
				sequence_PredicateFunction(context, (PredicateFunctionWHappensBeforeEvent) semanticObject); 
				return; 
			case MyDslPackage.PRIMARY_EXPRESSION_FUNCTION_CALL:
				sequence_PrimaryExpression(context, (PrimaryExpressionFunctionCall) semanticObject); 
				return; 
			case MyDslPackage.PRIMARY_EXPRESSION_RECURSIVE:
				sequence_PrimaryExpression(context, (PrimaryExpressionRecursive) semanticObject); 
				return; 
			case MyDslPackage.PRIMITIVE:
				sequence_Primitive(context, (Primitive) semanticObject); 
				return; 
			case MyDslPackage.PRIMITIVE_VARIABLE:
				sequence_PrimitiveVariable(context, (PrimitiveVariable) semanticObject); 
				return; 
			case MyDslPackage.SITUATION_EXPRESSION:
				sequence_IntervalExpression(context, (SituationExpression) semanticObject); 
				return; 
			case MyDslPackage.THREE_ARG_DATE_FUNCTION:
				sequence_DateFunction(context, (ThreeArgDateFunction) semanticObject); 
				return; 
			case MyDslPackage.THREE_ARG_STRING_FUNCTION:
				sequence_StringFunction(context, (ThreeArgStringFunction) semanticObject); 
				return; 
			case MyDslPackage.TIMEVALUE_INT:
				sequence_Timevalue(context, (TimevalueInt) semanticObject); 
				return; 
			case MyDslPackage.TIMEVALUE_VARIABLE:
				sequence_Timevalue(context, (TimevalueVariable) semanticObject); 
				return; 
			case MyDslPackage.TWO_ARG_MATH_FUNCTION:
				sequence_MathFunction(context, (TwoArgMathFunction) semanticObject); 
				return; 
			case MyDslPackage.TWO_ARG_STRING_FUNCTION:
				sequence_StringFunction(context, (TwoArgStringFunction) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_DOT_EXPRESSION:
				sequence_VariableDotExpression(context, (VariableDotExpression) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_EVENT:
				sequence_VariableEvent(context, (VariableEvent) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Plus_1_0_0_0 returns Minus
	 *     Addition.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_1_0 right=Multiplication)
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     Addition returns Plus
	 *     Addition.Plus_1_0_0_0 returns Plus
	 *     Addition.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=Addition_Plus_1_0_0_0 right=Multiplication)
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns AdvancedVariable
	 *     AdvancedVariable returns AdvancedVariable
	 *
	 * Constraint:
	 *     (type=[BaseEntity|ID] name=ID)
	 * </pre>
	 */
	protected void sequence_AdvancedVariable(ISerializationContext context, AdvancedVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADVANCED_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADVANCED_VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdvancedVariableAccess().getTypeBaseEntityIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MyDslPackage.Literals.ADVANCED_VARIABLE__TYPE, false));
		feeder.accept(grammarAccess.getAdvancedVariableAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionDate
	 *     Or returns AtomicExpressionDate
	 *     Or.Or_1_0 returns AtomicExpressionDate
	 *     And returns AtomicExpressionDate
	 *     And.And_1_0 returns AtomicExpressionDate
	 *     Equality returns AtomicExpressionDate
	 *     Equality.Equality_1_0 returns AtomicExpressionDate
	 *     Comparison returns AtomicExpressionDate
	 *     Comparison.Comparison_1_0 returns AtomicExpressionDate
	 *     Addition returns AtomicExpressionDate
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionDate
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionDate
	 *     Multiplication returns AtomicExpressionDate
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionDate
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionDate
	 *     PrimaryExpression returns AtomicExpressionDate
	 *     AtomicExpression returns AtomicExpressionDate
	 *
	 * Constraint:
	 *     value=Date
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionDate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_DATE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_DATE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueDateParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionDouble
	 *     Or returns AtomicExpressionDouble
	 *     Or.Or_1_0 returns AtomicExpressionDouble
	 *     And returns AtomicExpressionDouble
	 *     And.And_1_0 returns AtomicExpressionDouble
	 *     Equality returns AtomicExpressionDouble
	 *     Equality.Equality_1_0 returns AtomicExpressionDouble
	 *     Comparison returns AtomicExpressionDouble
	 *     Comparison.Comparison_1_0 returns AtomicExpressionDouble
	 *     Addition returns AtomicExpressionDouble
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionDouble
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionDouble
	 *     Multiplication returns AtomicExpressionDouble
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionDouble
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionDouble
	 *     PrimaryExpression returns AtomicExpressionDouble
	 *     AtomicExpression returns AtomicExpressionDouble
	 *
	 * Constraint:
	 *     value=Double
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_DOUBLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_DOUBLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueDoubleParserRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionEnum
	 *     Or returns AtomicExpressionEnum
	 *     Or.Or_1_0 returns AtomicExpressionEnum
	 *     And returns AtomicExpressionEnum
	 *     And.And_1_0 returns AtomicExpressionEnum
	 *     Equality returns AtomicExpressionEnum
	 *     Equality.Equality_1_0 returns AtomicExpressionEnum
	 *     Comparison returns AtomicExpressionEnum
	 *     Comparison.Comparison_1_0 returns AtomicExpressionEnum
	 *     Addition returns AtomicExpressionEnum
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionEnum
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionEnum
	 *     Multiplication returns AtomicExpressionEnum
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionEnum
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionEnum
	 *     PrimaryExpression returns AtomicExpressionEnum
	 *     AtomicExpression returns AtomicExpressionEnum
	 *
	 * Constraint:
	 *     (enumeration=ID enumItem=ID)
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionEnum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUMERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUMERATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUM_ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_ENUM__ENUM_ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getEnumerationIDTerminalRuleCall_5_1_0(), semanticObject.getEnumeration());
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getEnumItemIDTerminalRuleCall_5_3_0(), semanticObject.getEnumItem());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionFalse
	 *     Or returns AtomicExpressionFalse
	 *     Or.Or_1_0 returns AtomicExpressionFalse
	 *     And returns AtomicExpressionFalse
	 *     And.And_1_0 returns AtomicExpressionFalse
	 *     Equality returns AtomicExpressionFalse
	 *     Equality.Equality_1_0 returns AtomicExpressionFalse
	 *     Comparison returns AtomicExpressionFalse
	 *     Comparison.Comparison_1_0 returns AtomicExpressionFalse
	 *     Addition returns AtomicExpressionFalse
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionFalse
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionFalse
	 *     Multiplication returns AtomicExpressionFalse
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionFalse
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionFalse
	 *     PrimaryExpression returns AtomicExpressionFalse
	 *     AtomicExpression returns AtomicExpressionFalse
	 *
	 * Constraint:
	 *     value='false'
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionFalse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_FALSE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_FALSE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueFalseKeyword_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionInt
	 *     Or returns AtomicExpressionInt
	 *     Or.Or_1_0 returns AtomicExpressionInt
	 *     And returns AtomicExpressionInt
	 *     And.And_1_0 returns AtomicExpressionInt
	 *     Equality returns AtomicExpressionInt
	 *     Equality.Equality_1_0 returns AtomicExpressionInt
	 *     Comparison returns AtomicExpressionInt
	 *     Comparison.Comparison_1_0 returns AtomicExpressionInt
	 *     Addition returns AtomicExpressionInt
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionInt
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionInt
	 *     Multiplication returns AtomicExpressionInt
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionInt
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionInt
	 *     PrimaryExpression returns AtomicExpressionInt
	 *     AtomicExpression returns AtomicExpressionInt
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueINTTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionParameter
	 *     Or returns AtomicExpressionParameter
	 *     Or.Or_1_0 returns AtomicExpressionParameter
	 *     And returns AtomicExpressionParameter
	 *     And.And_1_0 returns AtomicExpressionParameter
	 *     Equality returns AtomicExpressionParameter
	 *     Equality.Equality_1_0 returns AtomicExpressionParameter
	 *     Comparison returns AtomicExpressionParameter
	 *     Comparison.Comparison_1_0 returns AtomicExpressionParameter
	 *     Addition returns AtomicExpressionParameter
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionParameter
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionParameter
	 *     Multiplication returns AtomicExpressionParameter
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionParameter
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionParameter
	 *     PrimaryExpression returns AtomicExpressionParameter
	 *     AtomicExpression returns AtomicExpressionParameter
	 *
	 * Constraint:
	 *     value=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_PARAMETER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_PARAMETER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueVariableDotExpressionParserRuleCall_7_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionString
	 *     Or returns AtomicExpressionString
	 *     Or.Or_1_0 returns AtomicExpressionString
	 *     And returns AtomicExpressionString
	 *     And.And_1_0 returns AtomicExpressionString
	 *     Equality returns AtomicExpressionString
	 *     Equality.Equality_1_0 returns AtomicExpressionString
	 *     Comparison returns AtomicExpressionString
	 *     Comparison.Comparison_1_0 returns AtomicExpressionString
	 *     Addition returns AtomicExpressionString
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionString
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionString
	 *     Multiplication returns AtomicExpressionString
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionString
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionString
	 *     PrimaryExpression returns AtomicExpressionString
	 *     AtomicExpression returns AtomicExpressionString
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AtomicExpressionTrue
	 *     Or returns AtomicExpressionTrue
	 *     Or.Or_1_0 returns AtomicExpressionTrue
	 *     And returns AtomicExpressionTrue
	 *     And.And_1_0 returns AtomicExpressionTrue
	 *     Equality returns AtomicExpressionTrue
	 *     Equality.Equality_1_0 returns AtomicExpressionTrue
	 *     Comparison returns AtomicExpressionTrue
	 *     Comparison.Comparison_1_0 returns AtomicExpressionTrue
	 *     Addition returns AtomicExpressionTrue
	 *     Addition.Plus_1_0_0_0 returns AtomicExpressionTrue
	 *     Addition.Minus_1_0_1_0 returns AtomicExpressionTrue
	 *     Multiplication returns AtomicExpressionTrue
	 *     Multiplication.Multi_1_0_0_0 returns AtomicExpressionTrue
	 *     Multiplication.Div_1_0_1_0 returns AtomicExpressionTrue
	 *     PrimaryExpression returns AtomicExpressionTrue
	 *     AtomicExpression returns AtomicExpressionTrue
	 *
	 * Constraint:
	 *     value='true'
	 * </pre>
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpressionTrue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_TRUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ATOMIC_EXPRESSION_TRUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueTrueKeyword_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClauseBody returns ClauseBody
	 *
	 * Constraint:
	 *     commands+=Command+
	 * </pre>
	 */
	protected void sequence_ClauseBody(ISerializationContext context, ClauseBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClauseParameter returns ClauseParameter
	 *
	 * Constraint:
	 *     (name=ID entity=[Entity|ID])
	 * </pre>
	 */
	protected void sequence_ClauseParameter(ISerializationContext context, ClauseParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CLAUSE_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CLAUSE_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CLAUSE_PARAMETER__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CLAUSE_PARAMETER__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClauseParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getClauseParameterAccess().getEntityEntityIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MyDslPackage.Literals.CLAUSE_PARAMETER__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Clause returns Clause
	 *
	 * Constraint:
	 *     (name=ID (params+=ClauseParameter params+=ClauseParameter*)? returnEntity=ID body=ClauseBody)
	 * </pre>
	 */
	protected void sequence_Clause(ISerializationContext context, Clause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     {Command}
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='&gt;=' | op='&lt;=' | op='&gt;' | op='&lt;') right=Addition)
	 * </pre>
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     ((type='pre' | type='post') prop=Proposition)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Constraint
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     contsr=Proposition
	 * </pre>
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONSTRAINT__CONTSR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONSTRAINT__CONTSR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getContsrPropositionParserRuleCall_1_0(), semanticObject.getContsr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns ContractEvent
	 *     ContractEvent returns ContractEvent
	 *
	 * Constraint:
	 *     eventName=ContractEventName
	 * </pre>
	 */
	protected void sequence_ContractEvent(ISerializationContext context, ContractEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONTRACT_EVENT__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONTRACT_EVENT__EVENT_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractEventAccess().getEventNameContractEventNameParserRuleCall_1_0(), semanticObject.getEventName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns ContractState
	 *     ContractState returns ContractState
	 *
	 * Constraint:
	 *     stateName=ContractStateName
	 * </pre>
	 */
	protected void sequence_ContractState(ISerializationContext context, ContractState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SITUATION__STATE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SITUATION__STATE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractStateAccess().getStateNameContractStateNameParserRuleCall_0_0(), semanticObject.getStateName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (name=ID contractAsset=ID)
	 * </pre>
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONTRACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONTRACT__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONTRACT__CONTRACT_ASSET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONTRACT__CONTRACT_ASSET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContractAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getContractAccess().getContractAssetIDTerminalRuleCall_3_0(), semanticObject.getContractAsset());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns ThreeArgDateFunction
	 *     DateFunction returns ThreeArgDateFunction
	 *
	 * Constraint:
	 *     (name='Date.add' arg1=Expression value=Expression timeUnit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_DateFunction(ISerializationContext context, ThreeArgDateFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__ARG1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.THREE_ARG_DATE_FUNCTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.THREE_ARG_DATE_FUNCTION__VALUE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.THREE_ARG_DATE_FUNCTION__TIME_UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.THREE_ARG_DATE_FUNCTION__TIME_UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateFunctionAccess().getNameDateAddKeyword_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDateFunctionAccess().getArg1ExpressionParserRuleCall_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getDateFunctionAccess().getValueExpressionParserRuleCall_5_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getDateFunctionAccess().getTimeUnitTimeUnitParserRuleCall_7_0(), semanticObject.getTimeUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Declaration
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (name=ID value=EntityDeclaration)
	 * </pre>
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclarationAccess().getNameIDTerminalRuleCall_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDeclarationAccess().getValueEntityDeclarationParserRuleCall_0_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entities returns Entities
	 *
	 * Constraint:
	 *     (domainName=ID entities+=BaseEntity+)
	 * </pre>
	 */
	protected void sequence_Entities(ISerializationContext context, Entities semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EntityDeclarationParam returns EntityDeclarationParam
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 * </pre>
	 */
	protected void sequence_EntityDeclarationParam(ISerializationContext context, EntityDeclarationParam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENTITY_DECLARATION_PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENTITY_DECLARATION_PARAM__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENTITY_DECLARATION_PARAM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENTITY_DECLARATION_PARAM__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityDeclarationParamAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEntityDeclarationParamAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EntityDeclaration returns EntityDeclaration
	 *
	 * Constraint:
	 *     (name=[Entity|ID] (params+=EntityDeclarationParam params+=EntityDeclarationParam*)?)
	 * </pre>
	 */
	protected void sequence_EntityDeclaration(ISerializationContext context, EntityDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EntityType returns EntityType
	 *
	 * Constraint:
	 *     (name='transaction' | name='asset' | name='concept' | name='participant')
	 * </pre>
	 */
	protected void sequence_EntityType(ISerializationContext context, EntityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BaseEntity returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (type=EntityType name=ID parent=[BaseEntity|ID]? idVariable=[Variable|ID]? variables+=Variable*)
	 * </pre>
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BaseEntity returns EnumEntity
	 *     EnumEntity returns EnumEntity
	 *
	 * Constraint:
	 *     (name=ID parent=[BaseEntity|ID]? variables+=EnumMember*)
	 * </pre>
	 */
	protected void sequence_EnumEntity(ISerializationContext context, EnumEntity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumMember returns EnumMember
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EnumMember(ISerializationContext context, EnumMember semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ENUM_MEMBER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ENUM_MEMBER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumMemberAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntervalExpression returns IntervalFunction
	 *
	 * Constraint:
	 *     (arg1=PointExpression arg2=PointExpression)
	 * </pre>
	 */
	protected void sequence_IntervalExpression(ISerializationContext context, IntervalFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INTERVAL_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INTERVAL_FUNCTION__ARG1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INTERVAL_FUNCTION__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INTERVAL_FUNCTION__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalExpressionAccess().getArg1PointExpressionParserRuleCall_0_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getIntervalExpressionAccess().getArg2PointExpressionParserRuleCall_0_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntervalExpression returns SituationExpression
	 *
	 * Constraint:
	 *     situation=Situation
	 * </pre>
	 */
	protected void sequence_IntervalExpression(ISerializationContext context, SituationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SITUATION_EXPRESSION__SITUATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SITUATION_EXPRESSION__SITUATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalExpressionAccess().getSituationSituationParserRuleCall_1_1_0(), semanticObject.getSituation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     intervalExpression=IntervalExpression
	 * </pre>
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INTERVAL__INTERVAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INTERVAL__INTERVAL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalAccess().getIntervalExpressionIntervalExpressionParserRuleCall_0(), semanticObject.getIntervalExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Logic returns Logic
	 *
	 * Constraint:
	 *     (domainName=ID contract=Contract clause=Clause)
	 * </pre>
	 */
	protected void sequence_Logic(ISerializationContext context, Logic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGIC__DOMAIN_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGIC__DOMAIN_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGIC__CONTRACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGIC__CONTRACT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGIC__CLAUSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGIC__CLAUSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicAccess().getDomainNameIDTerminalRuleCall_2_0(), semanticObject.getDomainName());
		feeder.accept(grammarAccess.getLogicAccess().getContractContractParserRuleCall_4_0(), semanticObject.getContract());
		feeder.accept(grammarAccess.getLogicAccess().getClauseClauseParserRuleCall_6_0(), semanticObject.getClause());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns OneArgMathFunction
	 *     MathFunction returns OneArgMathFunction
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name='Math.abs' | 
	 *             name='Math.floor' | 
	 *             name='Math.cbrt' | 
	 *             name='Math.ceil' | 
	 *             name='Math.exp' | 
	 *             name='Math.sign' | 
	 *             name='Math.sqrt'
	 *         ) 
	 *         arg1=Expression
	 *     )
	 * </pre>
	 */
	protected void sequence_MathFunction(ISerializationContext context, OneArgMathFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns TwoArgMathFunction
	 *     MathFunction returns TwoArgMathFunction
	 *
	 * Constraint:
	 *     (name='Math.pow' arg1=Expression arg2=Expression)
	 * </pre>
	 */
	protected void sequence_MathFunction(ISerializationContext context, TwoArgMathFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__ARG1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TWO_ARG_MATH_FUNCTION__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TWO_ARG_MATH_FUNCTION__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMathFunctionAccess().getNameMathPowKeyword_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMathFunctionAccess().getArg1ExpressionParserRuleCall_0_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getMathFunctionAccess().getArg2ExpressionParserRuleCall_0_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (entities=Entities logic=Logic)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MODEL__ENTITIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MODEL__ENTITIES));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MODEL__LOGIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MODEL__LOGIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getEntitiesEntitiesParserRuleCall_0_0(), semanticObject.getEntities());
		feeder.accept(grammarAccess.getModelAccess().getLogicLogicParserRuleCall_1_0(), semanticObject.getLogic());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     Addition returns Div
	 *     Addition.Plus_1_0_0_0 returns Div
	 *     Addition.Minus_1_0_1_0 returns Div
	 *     Multiplication returns Div
	 *     Multiplication.Multi_1_0_0_0 returns Div
	 *     Multiplication.Div_1_0_1_0 returns Div
	 *
	 * Constraint:
	 *     (left=Multiplication_Div_1_0_1_0 right=PrimaryExpression)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Multi
	 *     Or returns Multi
	 *     Or.Or_1_0 returns Multi
	 *     And returns Multi
	 *     And.And_1_0 returns Multi
	 *     Equality returns Multi
	 *     Equality.Equality_1_0 returns Multi
	 *     Comparison returns Multi
	 *     Comparison.Comparison_1_0 returns Multi
	 *     Addition returns Multi
	 *     Addition.Plus_1_0_0_0 returns Multi
	 *     Addition.Minus_1_0_1_0 returns Multi
	 *     Multiplication returns Multi
	 *     Multiplication.Multi_1_0_0_0 returns Multi
	 *     Multiplication.Div_1_0_1_0 returns Multi
	 *
	 * Constraint:
	 *     (left=Multiplication_Multi_1_0_0_0 right=PrimaryExpression)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multi semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTI__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTI__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTI__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTI__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns ObligationEvent
	 *     ObligationEvent returns ObligationEvent
	 *
	 * Constraint:
	 *     (eventName=ObligationEventName obligationVariable=[ObligationWrapper|ID])
	 * </pre>
	 */
	protected void sequence_ObligationEvent(ISerializationContext context, ObligationEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBLIGATION_EVENT__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBLIGATION_EVENT__EVENT_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBLIGATION_EVENT__OBLIGATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBLIGATION_EVENT__OBLIGATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObligationEventAccess().getEventNameObligationEventNameParserRuleCall_1_0(), semanticObject.getEventName());
		feeder.accept(grammarAccess.getObligationEventAccess().getObligationVariableObligationWrapperIDTerminalRuleCall_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.OBLIGATION_EVENT__OBLIGATION_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns ObligationState
	 *     ObligationState returns ObligationState
	 *
	 * Constraint:
	 *     (stateName=ObligationStateName obligationVariable=[ObligationWrapper|ID])
	 * </pre>
	 */
	protected void sequence_ObligationState(ISerializationContext context, ObligationState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SITUATION__STATE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SITUATION__STATE_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OBLIGATION_STATE__OBLIGATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OBLIGATION_STATE__OBLIGATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObligationStateAccess().getStateNameObligationStateNameParserRuleCall_0_0(), semanticObject.getStateName());
		feeder.accept(grammarAccess.getObligationStateAccess().getObligationVariableObligationWrapperIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MyDslPackage.Literals.OBLIGATION_STATE__OBLIGATION_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns ObligationWrapper
	 *     ObligationWrapper returns ObligationWrapper
	 *
	 * Constraint:
	 *     ((type='obl' | type='sobl') name=ID obl=Obligation)
	 * </pre>
	 */
	protected void sequence_ObligationWrapper(ISerializationContext context, ObligationWrapper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Obligation returns Obligation
	 *
	 * Constraint:
	 *     (trigger=Proposition? debtor=VariableDotExpression creditor=VariableDotExpression antecedent=Proposition consequent=Proposition)
	 * </pre>
	 */
	protected void sequence_Obligation(ISerializationContext context, Obligation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns OtherDeclaration
	 *     Declaration returns OtherDeclaration
	 *     OtherDeclaration returns OtherDeclaration
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_OtherDeclaration(ISerializationContext context, OtherDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherFunction returns PredicateFunctionCannotBeAssigned
	 *
	 * Constraint:
	 *     (name='CannotBeAssigned' arg1=ID)
	 * </pre>
	 */
	protected void sequence_OtherFunction(ISerializationContext context, PredicateFunctionCannotBeAssigned semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__ARG1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherFunctionAccess().getNameCannotBeAssignedKeyword_2_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg1IDTerminalRuleCall_2_3_0(), semanticObject.getArg1());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherFunction returns PredicateFunctionIsEqual
	 *
	 * Constraint:
	 *     (name='IsEqual' arg1=ID arg2=ID)
	 * </pre>
	 */
	protected void sequence_OtherFunction(ISerializationContext context, PredicateFunctionIsEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__ARG1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_IS_EQUAL__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_IS_EQUAL__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherFunctionAccess().getNameIsEqualKeyword_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg1IDTerminalRuleCall_0_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg2IDTerminalRuleCall_0_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherFunction returns PredicateFunctionIsOwner
	 *
	 * Constraint:
	 *     (name='IsOwner' arg1=ID arg2=ID)
	 * </pre>
	 */
	protected void sequence_OtherFunction(ISerializationContext context, PredicateFunctionIsOwner semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.OTHER_FUNCTION__ARG1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_IS_OWNER__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_IS_OWNER__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherFunctionAccess().getNameIsOwnerKeyword_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg1IDTerminalRuleCall_1_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getOtherFunctionAccess().getArg2IDTerminalRuleCall_1_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAnd
	 *     POr returns PAnd
	 *     POr.POr_1_0 returns PAnd
	 *     PAnd returns PAnd
	 *     PAnd.PAnd_1_0 returns PAnd
	 *
	 * Constraint:
	 *     (left=PAnd_PAnd_1_0 right=PEquality)
	 * </pre>
	 */
	protected void sequence_PAnd(ISerializationContext context, PAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PAND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PAND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PAND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PAND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAndAccess().getPAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPAndAccess().getRightPEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns NegatedPAtom
	 *     POr returns NegatedPAtom
	 *     POr.POr_1_0 returns NegatedPAtom
	 *     PAnd returns NegatedPAtom
	 *     PAnd.PAnd_1_0 returns NegatedPAtom
	 *     PEquality returns NegatedPAtom
	 *     PEquality.PEquality_1_0 returns NegatedPAtom
	 *     PComparison returns NegatedPAtom
	 *     PComparison.PComparison_1_0 returns NegatedPAtom
	 *     PAtomicExpression returns NegatedPAtom
	 *
	 * Constraint:
	 *     negated=PAtomicExpression
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, NegatedPAtom semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NEGATED_PATOM__NEGATED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NEGATED_PATOM__NEGATED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getNegatedPAtomicExpressionParserRuleCall_1_2_0(), semanticObject.getNegated());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomDateLiteral
	 *     POr returns PAtomDateLiteral
	 *     POr.POr_1_0 returns PAtomDateLiteral
	 *     PAnd returns PAtomDateLiteral
	 *     PAnd.PAnd_1_0 returns PAtomDateLiteral
	 *     PEquality returns PAtomDateLiteral
	 *     PEquality.PEquality_1_0 returns PAtomDateLiteral
	 *     PComparison returns PAtomDateLiteral
	 *     PComparison.PComparison_1_0 returns PAtomDateLiteral
	 *     PAtomicExpression returns PAtomDateLiteral
	 *
	 * Constraint:
	 *     value=Date
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomDateLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_DATE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_DATE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueDateParserRuleCall_11_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomDoubleLiteral
	 *     POr returns PAtomDoubleLiteral
	 *     POr.POr_1_0 returns PAtomDoubleLiteral
	 *     PAnd returns PAtomDoubleLiteral
	 *     PAnd.PAnd_1_0 returns PAtomDoubleLiteral
	 *     PEquality returns PAtomDoubleLiteral
	 *     PEquality.PEquality_1_0 returns PAtomDoubleLiteral
	 *     PComparison returns PAtomDoubleLiteral
	 *     PComparison.PComparison_1_0 returns PAtomDoubleLiteral
	 *     PAtomicExpression returns PAtomDoubleLiteral
	 *
	 * Constraint:
	 *     value=Double
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomDoubleLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_DOUBLE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_DOUBLE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueDoubleParserRuleCall_8_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomEnum
	 *     POr returns PAtomEnum
	 *     POr.POr_1_0 returns PAtomEnum
	 *     PAnd returns PAtomEnum
	 *     PAnd.PAnd_1_0 returns PAtomEnum
	 *     PEquality returns PAtomEnum
	 *     PEquality.PEquality_1_0 returns PAtomEnum
	 *     PComparison returns PAtomEnum
	 *     PComparison.PComparison_1_0 returns PAtomEnum
	 *     PAtomicExpression returns PAtomEnum
	 *
	 * Constraint:
	 *     (enumeration=ID enumItem=ID)
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomEnum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_ENUM__ENUMERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_ENUM__ENUMERATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_ENUM__ENUM_ITEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_ENUM__ENUM_ITEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getEnumerationIDTerminalRuleCall_4_1_0(), semanticObject.getEnumeration());
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getEnumItemIDTerminalRuleCall_4_3_0(), semanticObject.getEnumItem());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomFunction
	 *     POr returns PAtomFunction
	 *     POr.POr_1_0 returns PAtomFunction
	 *     PAnd returns PAtomFunction
	 *     PAnd.PAnd_1_0 returns PAtomFunction
	 *     PEquality returns PAtomFunction
	 *     PEquality.PEquality_1_0 returns PAtomFunction
	 *     PComparison returns PAtomFunction
	 *     PComparison.PComparison_1_0 returns PAtomFunction
	 *     PAtomicExpression returns PAtomFunction
	 *
	 * Constraint:
	 *     function=OtherFunction
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_FUNCTION__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_FUNCTION__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getFunctionOtherFunctionParserRuleCall_3_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomIntLiteral
	 *     POr returns PAtomIntLiteral
	 *     POr.POr_1_0 returns PAtomIntLiteral
	 *     PAnd returns PAtomIntLiteral
	 *     PAnd.PAnd_1_0 returns PAtomIntLiteral
	 *     PEquality returns PAtomIntLiteral
	 *     PEquality.PEquality_1_0 returns PAtomIntLiteral
	 *     PComparison returns PAtomIntLiteral
	 *     PComparison.PComparison_1_0 returns PAtomIntLiteral
	 *     PAtomicExpression returns PAtomIntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomIntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueINTTerminalRuleCall_9_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomPredicate
	 *     POr returns PAtomPredicate
	 *     POr.POr_1_0 returns PAtomPredicate
	 *     PAnd returns PAtomPredicate
	 *     PAnd.PAnd_1_0 returns PAtomPredicate
	 *     PEquality returns PAtomPredicate
	 *     PEquality.PEquality_1_0 returns PAtomPredicate
	 *     PComparison returns PAtomPredicate
	 *     PComparison.PComparison_1_0 returns PAtomPredicate
	 *     PAtomicExpression returns PAtomPredicate
	 *
	 * Constraint:
	 *     predicateFunction=PredicateFunction
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_PREDICATE__PREDICATE_FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_PREDICATE__PREDICATE_FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getPredicateFunctionPredicateFunctionParserRuleCall_2_1_0(), semanticObject.getPredicateFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomPredicateFalseLiteral
	 *     POr returns PAtomPredicateFalseLiteral
	 *     POr.POr_1_0 returns PAtomPredicateFalseLiteral
	 *     PAnd returns PAtomPredicateFalseLiteral
	 *     PAnd.PAnd_1_0 returns PAtomPredicateFalseLiteral
	 *     PEquality returns PAtomPredicateFalseLiteral
	 *     PEquality.PEquality_1_0 returns PAtomPredicateFalseLiteral
	 *     PComparison returns PAtomPredicateFalseLiteral
	 *     PComparison.PComparison_1_0 returns PAtomPredicateFalseLiteral
	 *     PAtomicExpression returns PAtomPredicateFalseLiteral
	 *
	 * Constraint:
	 *     value='false'
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomPredicateFalseLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_PREDICATE_FALSE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_PREDICATE_FALSE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueFalseKeyword_7_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomPredicateTrueLiteral
	 *     POr returns PAtomPredicateTrueLiteral
	 *     POr.POr_1_0 returns PAtomPredicateTrueLiteral
	 *     PAnd returns PAtomPredicateTrueLiteral
	 *     PAnd.PAnd_1_0 returns PAtomPredicateTrueLiteral
	 *     PEquality returns PAtomPredicateTrueLiteral
	 *     PEquality.PEquality_1_0 returns PAtomPredicateTrueLiteral
	 *     PComparison returns PAtomPredicateTrueLiteral
	 *     PComparison.PComparison_1_0 returns PAtomPredicateTrueLiteral
	 *     PAtomicExpression returns PAtomPredicateTrueLiteral
	 *
	 * Constraint:
	 *     value='true'
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomPredicateTrueLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_PREDICATE_TRUE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_PREDICATE_TRUE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueTrueKeyword_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomRecursive
	 *     POr returns PAtomRecursive
	 *     POr.POr_1_0 returns PAtomRecursive
	 *     PAnd returns PAtomRecursive
	 *     PAnd.PAnd_1_0 returns PAtomRecursive
	 *     PEquality returns PAtomRecursive
	 *     PEquality.PEquality_1_0 returns PAtomRecursive
	 *     PComparison returns PAtomRecursive
	 *     PComparison.PComparison_1_0 returns PAtomRecursive
	 *     PAtomicExpression returns PAtomRecursive
	 *
	 * Constraint:
	 *     inner=Proposition
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomRecursive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_RECURSIVE__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_RECURSIVE__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getInnerPropositionParserRuleCall_0_2_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomStringLiteral
	 *     POr returns PAtomStringLiteral
	 *     POr.POr_1_0 returns PAtomStringLiteral
	 *     PAnd returns PAtomStringLiteral
	 *     PAnd.PAnd_1_0 returns PAtomStringLiteral
	 *     PEquality returns PAtomStringLiteral
	 *     PEquality.PEquality_1_0 returns PAtomStringLiteral
	 *     PComparison returns PAtomStringLiteral
	 *     PComparison.PComparison_1_0 returns PAtomStringLiteral
	 *     PAtomicExpression returns PAtomStringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomStringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_10_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PAtomVariable
	 *     POr returns PAtomVariable
	 *     POr.POr_1_0 returns PAtomVariable
	 *     PAnd returns PAtomVariable
	 *     PAnd.PAnd_1_0 returns PAtomVariable
	 *     PEquality returns PAtomVariable
	 *     PEquality.PEquality_1_0 returns PAtomVariable
	 *     PComparison returns PAtomVariable
	 *     PComparison.PComparison_1_0 returns PAtomVariable
	 *     PAtomicExpression returns PAtomVariable
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_PAtomicExpression(ISerializationContext context, PAtomVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PATOM_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PATOM_VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAtomicExpressionAccess().getVariableVariableDotExpressionParserRuleCall_5_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PComparison
	 *     POr returns PComparison
	 *     POr.POr_1_0 returns PComparison
	 *     PAnd returns PComparison
	 *     PAnd.PAnd_1_0 returns PComparison
	 *     PEquality returns PComparison
	 *     PEquality.PEquality_1_0 returns PComparison
	 *     PComparison returns PComparison
	 *     PComparison.PComparison_1_0 returns PComparison
	 *
	 * Constraint:
	 *     (left=PComparison_PComparison_1_0 (op='&gt;=' | op='&lt;=' | op='&gt;' | op='&lt;') right=PAtomicExpression)
	 * </pre>
	 */
	protected void sequence_PComparison(ISerializationContext context, PComparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns PEquality
	 *     POr returns PEquality
	 *     POr.POr_1_0 returns PEquality
	 *     PAnd returns PEquality
	 *     PAnd.PAnd_1_0 returns PEquality
	 *     PEquality returns PEquality
	 *     PEquality.PEquality_1_0 returns PEquality
	 *
	 * Constraint:
	 *     (left=PEquality_PEquality_1_0 (op='==' | op='!=') right=PComparison)
	 * </pre>
	 */
	protected void sequence_PEquality(ISerializationContext context, PEquality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Proposition returns POr
	 *     POr returns POr
	 *     POr.POr_1_0 returns POr
	 *
	 * Constraint:
	 *     (left=POr_POr_1_0 right=PAnd)
	 * </pre>
	 */
	protected void sequence_POr(ISerializationContext context, POr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPOrAccess().getPOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPOrAccess().getRightPAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomContractEvent
	 *     PointAtom returns PointAtomContractEvent
	 *
	 * Constraint:
	 *     contractEvent=ContractEvent
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomContractEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_ATOM_CONTRACT_EVENT__CONTRACT_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_ATOM_CONTRACT_EVENT__CONTRACT_EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getContractEventContractEventParserRuleCall_2_1_0(), semanticObject.getContractEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomObligationEvent
	 *     PointAtom returns PointAtomObligationEvent
	 *
	 * Constraint:
	 *     obligationEvent=ObligationEvent
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomObligationEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_ATOM_OBLIGATION_EVENT__OBLIGATION_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_ATOM_OBLIGATION_EVENT__OBLIGATION_EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getObligationEventObligationEventParserRuleCall_1_1_0(), semanticObject.getObligationEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomParameterDotExpression
	 *     PointAtom returns PointAtomParameterDotExpression
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomParameterDotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_ATOM_PARAMETER_DOT_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_ATOM_PARAMETER_DOT_EXPRESSION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getVariableVariableDotExpressionParserRuleCall_0_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointAtomPowerEvent
	 *     PointAtom returns PointAtomPowerEvent
	 *
	 * Constraint:
	 *     powerEvent=PowerEvent
	 * </pre>
	 */
	protected void sequence_PointAtom(ISerializationContext context, PointAtomPowerEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_ATOM_POWER_EVENT__POWER_EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_ATOM_POWER_EVENT__POWER_EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAtomAccess().getPowerEventPowerEventParserRuleCall_3_1_0(), semanticObject.getPowerEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PointExpression returns PointFunction
	 *     PointFunction returns PointFunction
	 *
	 * Constraint:
	 *     (name=PointFunctionName arg=PointExpression value=Timevalue timeUnit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_PointFunction(ISerializationContext context, PointFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__ARG));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__VALUE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__TIME_UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT_FUNCTION__TIME_UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointFunctionAccess().getNamePointFunctionNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPointFunctionAccess().getArgPointExpressionParserRuleCall_3_0(), semanticObject.getArg());
		feeder.accept(grammarAccess.getPointFunctionAccess().getValueTimevalueParserRuleCall_5_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getPointFunctionAccess().getTimeUnitTimeUnitParserRuleCall_7_0(), semanticObject.getTimeUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     pointExpression=PointExpression
	 * </pre>
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POINT__POINT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POINT__POINT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAccess().getPointExpressionPointExpressionParserRuleCall_0(), semanticObject.getPointExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns PowerEvent
	 *     PowerEvent returns PowerEvent
	 *
	 * Constraint:
	 *     (eventName=PowerEventName powerVariable=[PowerWrapper|ID])
	 * </pre>
	 */
	protected void sequence_PowerEvent(ISerializationContext context, PowerEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_EVENT__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_EVENT__EVENT_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_EVENT__POWER_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_EVENT__POWER_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerEventAccess().getEventNamePowerEventNameParserRuleCall_1_0(), semanticObject.getEventName());
		feeder.accept(grammarAccess.getPowerEventAccess().getPowerVariablePowerWrapperIDTerminalRuleCall_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.POWER_EVENT__POWER_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFContractResumed
	 *
	 * Constraint:
	 *     (action='Resumed' norm='self')
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFContractResumed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_CONTRACT_RESUMED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_CONTRACT_RESUMED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionResumedKeyword_6_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormSelfKeyword_6_3_0(), semanticObject.getNorm());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFContractSuspended
	 *
	 * Constraint:
	 *     (action='Suspended' norm='self')
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFContractSuspended semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_CONTRACT_SUSPENDED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_CONTRACT_SUSPENDED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionSuspendedKeyword_5_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormSelfKeyword_5_3_0(), semanticObject.getNorm());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFContractTerminated
	 *
	 * Constraint:
	 *     (action='Terminated' norm='self')
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFContractTerminated semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_CONTRACT_TERMINATED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_CONTRACT_TERMINATED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionTerminatedKeyword_7_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormSelfKeyword_7_3_0(), semanticObject.getNorm());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationDischarged
	 *
	 * Constraint:
	 *     (action='Discharged' norm=[ObligationWrapper|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationDischarged semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_DISCHARGED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_DISCHARGED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionDischargedKeyword_2_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationWrapperIDTerminalRuleCall_2_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.PF_OBLIGATION_DISCHARGED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationResumed
	 *
	 * Constraint:
	 *     (action='Resumed' norm=[ObligationWrapper|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationResumed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_RESUMED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_RESUMED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionResumedKeyword_1_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationWrapperIDTerminalRuleCall_1_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.PF_OBLIGATION_RESUMED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationSuspended
	 *
	 * Constraint:
	 *     (action='Suspended' norm=[ObligationWrapper|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationSuspended semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_SUSPENDED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_SUSPENDED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionSuspendedKeyword_0_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationWrapperIDTerminalRuleCall_0_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.PF_OBLIGATION_SUSPENDED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationTerminated
	 *
	 * Constraint:
	 *     (action='Terminated' norm=[ObligationWrapper|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationTerminated semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_TERMINATED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_TERMINATED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionTerminatedKeyword_3_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationWrapperIDTerminalRuleCall_3_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.PF_OBLIGATION_TERMINATED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PowerFunction returns PFObligationTriggered
	 *
	 * Constraint:
	 *     (action='Triggered' norm=[ObligationWrapper|ID])
	 * </pre>
	 */
	protected void sequence_PowerFunction(ISerializationContext context, PFObligationTriggered semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_FUNCTION__ACTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_TRIGGERED__NORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PF_OBLIGATION_TRIGGERED__NORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerFunctionAccess().getActionTriggeredKeyword_4_1_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getPowerFunctionAccess().getNormObligationWrapperIDTerminalRuleCall_4_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.PF_OBLIGATION_TRIGGERED__NORM, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Situation returns PowerState
	 *     PowerState returns PowerState
	 *
	 * Constraint:
	 *     (stateName=PowerStateName powerVariable=[PowerWrapper|ID])
	 * </pre>
	 */
	protected void sequence_PowerState(ISerializationContext context, PowerState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SITUATION__STATE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SITUATION__STATE_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_STATE__POWER_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_STATE__POWER_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerStateAccess().getStateNamePowerStateNameParserRuleCall_0_0(), semanticObject.getStateName());
		feeder.accept(grammarAccess.getPowerStateAccess().getPowerVariablePowerWrapperIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MyDslPackage.Literals.POWER_STATE__POWER_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns PowerWrapper
	 *     PowerWrapper returns PowerWrapper
	 *
	 * Constraint:
	 *     (name=ID pow=Power)
	 * </pre>
	 */
	protected void sequence_PowerWrapper(ISerializationContext context, PowerWrapper semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_WRAPPER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_WRAPPER__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POWER_WRAPPER__POW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POWER_WRAPPER__POW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowerWrapperAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPowerWrapperAccess().getPowPowerParserRuleCall_3_0(), semanticObject.getPow());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Power returns Power
	 *
	 * Constraint:
	 *     (trigger=Proposition? creditor=VariableDotExpression debtor=VariableDotExpression antecedent=Proposition consequent=PowerFunction)
	 * </pre>
	 */
	protected void sequence_Power(ISerializationContext context, Power semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionHappens
	 *
	 * Constraint:
	 *     (name='Happens' event=Event)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionHappens semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameHappensKeyword_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_0_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionHappensAfter
	 *
	 * Constraint:
	 *     (name='HappensAfter' event=Event point=Point)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionHappensAfter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__EVENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_AFTER__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameHappensAfterKeyword_6_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_6_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getPointPointParserRuleCall_6_5_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionHappensWithin
	 *
	 * Constraint:
	 *     (name='HappensWithin' event=Event interval=Interval)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionHappensWithin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__EVENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_HAPPENS_WITHIN__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameHappensWithinKeyword_3_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_3_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getIntervalIntervalParserRuleCall_3_5_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionOccurs
	 *
	 * Constraint:
	 *     (name='Occurs' situation=Situation interval=Interval)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionOccurs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_OCCURS__SITUATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_OCCURS__SITUATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_OCCURS__INTERVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_OCCURS__INTERVAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameOccursKeyword_7_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getSituationSituationParserRuleCall_7_3_0(), semanticObject.getSituation());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getIntervalIntervalParserRuleCall_7_5_0(), semanticObject.getInterval());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionSHappensBefore
	 *
	 * Constraint:
	 *     (name='ShappensBefore' event=Event point=Point)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionSHappensBefore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__EVENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameShappensBeforeKeyword_2_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_2_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getPointPointParserRuleCall_2_5_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionSHappensBeforeEvent
	 *
	 * Constraint:
	 *     (name='ShappensBeforeE' event1=Event event2=Event)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionSHappensBeforeEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_SHAPPENS_BEFORE_EVENT__EVENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameShappensBeforeEKeyword_5_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent1EventParserRuleCall_5_3_0(), semanticObject.getEvent1());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent2EventParserRuleCall_5_5_0(), semanticObject.getEvent2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionWHappensBefore
	 *
	 * Constraint:
	 *     (name='WhappensBefore' event=Event point=Point)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionWHappensBefore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__EVENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE__POINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameWhappensBeforeKeyword_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEventEventParserRuleCall_1_3_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getPointPointParserRuleCall_1_5_0(), semanticObject.getPoint());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PredicateFunction returns PredicateFunctionWHappensBeforeEvent
	 *
	 * Constraint:
	 *     (name='WhappensBeforeE' event1=Event event2=Event)
	 * </pre>
	 */
	protected void sequence_PredicateFunction(ISerializationContext context, PredicateFunctionWHappensBeforeEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PREDICATE_FUNCTION_WHAPPENS_BEFORE_EVENT__EVENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getNameWhappensBeforeEKeyword_4_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent1EventParserRuleCall_4_3_0(), semanticObject.getEvent1());
		feeder.accept(grammarAccess.getPredicateFunctionAccess().getEvent2EventParserRuleCall_4_5_0(), semanticObject.getEvent2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NegatedPrimaryExpression
	 *     Or returns NegatedPrimaryExpression
	 *     Or.Or_1_0 returns NegatedPrimaryExpression
	 *     And returns NegatedPrimaryExpression
	 *     And.And_1_0 returns NegatedPrimaryExpression
	 *     Equality returns NegatedPrimaryExpression
	 *     Equality.Equality_1_0 returns NegatedPrimaryExpression
	 *     Comparison returns NegatedPrimaryExpression
	 *     Comparison.Comparison_1_0 returns NegatedPrimaryExpression
	 *     Addition returns NegatedPrimaryExpression
	 *     Addition.Plus_1_0_0_0 returns NegatedPrimaryExpression
	 *     Addition.Minus_1_0_1_0 returns NegatedPrimaryExpression
	 *     Multiplication returns NegatedPrimaryExpression
	 *     Multiplication.Multi_1_0_0_0 returns NegatedPrimaryExpression
	 *     Multiplication.Div_1_0_1_0 returns NegatedPrimaryExpression
	 *     PrimaryExpression returns NegatedPrimaryExpression
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, NegatedPrimaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NEGATED_PRIMARY_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NEGATED_PRIMARY_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns PrimaryExpressionFunctionCall
	 *     Or returns PrimaryExpressionFunctionCall
	 *     Or.Or_1_0 returns PrimaryExpressionFunctionCall
	 *     And returns PrimaryExpressionFunctionCall
	 *     And.And_1_0 returns PrimaryExpressionFunctionCall
	 *     Equality returns PrimaryExpressionFunctionCall
	 *     Equality.Equality_1_0 returns PrimaryExpressionFunctionCall
	 *     Comparison returns PrimaryExpressionFunctionCall
	 *     Comparison.Comparison_1_0 returns PrimaryExpressionFunctionCall
	 *     Addition returns PrimaryExpressionFunctionCall
	 *     Addition.Plus_1_0_0_0 returns PrimaryExpressionFunctionCall
	 *     Addition.Minus_1_0_1_0 returns PrimaryExpressionFunctionCall
	 *     Multiplication returns PrimaryExpressionFunctionCall
	 *     Multiplication.Multi_1_0_0_0 returns PrimaryExpressionFunctionCall
	 *     Multiplication.Div_1_0_1_0 returns PrimaryExpressionFunctionCall
	 *     PrimaryExpression returns PrimaryExpressionFunctionCall
	 *
	 * Constraint:
	 *     function=FunctionCall
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpressionFunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PRIMARY_EXPRESSION_FUNCTION_CALL__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PRIMARY_EXPRESSION_FUNCTION_CALL__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getFunctionFunctionCallParserRuleCall_1_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns PrimaryExpressionRecursive
	 *     Or returns PrimaryExpressionRecursive
	 *     Or.Or_1_0 returns PrimaryExpressionRecursive
	 *     And returns PrimaryExpressionRecursive
	 *     And.And_1_0 returns PrimaryExpressionRecursive
	 *     Equality returns PrimaryExpressionRecursive
	 *     Equality.Equality_1_0 returns PrimaryExpressionRecursive
	 *     Comparison returns PrimaryExpressionRecursive
	 *     Comparison.Comparison_1_0 returns PrimaryExpressionRecursive
	 *     Addition returns PrimaryExpressionRecursive
	 *     Addition.Plus_1_0_0_0 returns PrimaryExpressionRecursive
	 *     Addition.Minus_1_0_1_0 returns PrimaryExpressionRecursive
	 *     Multiplication returns PrimaryExpressionRecursive
	 *     Multiplication.Multi_1_0_0_0 returns PrimaryExpressionRecursive
	 *     Multiplication.Div_1_0_1_0 returns PrimaryExpressionRecursive
	 *     PrimaryExpression returns PrimaryExpressionRecursive
	 *
	 * Constraint:
	 *     inner=Expression
	 * </pre>
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpressionRecursive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PRIMARY_EXPRESSION_RECURSIVE__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PRIMARY_EXPRESSION_RECURSIVE__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getInnerExpressionParserRuleCall_0_2_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns PrimitiveVariable
	 *     PrimitiveVariable returns PrimitiveVariable
	 *
	 * Constraint:
	 *     (type=Primitive name=ID)
	 * </pre>
	 */
	protected void sequence_PrimitiveVariable(ISerializationContext context, PrimitiveVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PRIMITIVE_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PRIMITIVE_VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveVariableAccess().getTypePrimitiveParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimitiveVariableAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Primitive returns Primitive
	 *
	 * Constraint:
	 *     (name='String' | name='Integer' | name='Boolean' | name='DateTime')
	 * </pre>
	 */
	protected void sequence_Primitive(ISerializationContext context, Primitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns OneArgStringFunction
	 *     StringFunction returns OneArgStringFunction
	 *
	 * Constraint:
	 *     (
	 *         (name='String.toLowerCase' | name='String.toUpperCase' | name='String.trimEnd' | name='String.trimStart' | name='String.trim') 
	 *         arg1=Expression
	 *     )
	 * </pre>
	 */
	protected void sequence_StringFunction(ISerializationContext context, OneArgStringFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns ThreeArgStringFunction
	 *     StringFunction returns ThreeArgStringFunction
	 *
	 * Constraint:
	 *     ((name='String.substring' | name='String.replaceAll') arg1=Expression arg2=Expression arg3=Expression)
	 * </pre>
	 */
	protected void sequence_StringFunction(ISerializationContext context, ThreeArgStringFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionCall returns TwoArgStringFunction
	 *     StringFunction returns TwoArgStringFunction
	 *
	 * Constraint:
	 *     (name='String.concat' arg1=Expression arg2=Expression)
	 * </pre>
	 */
	protected void sequence_StringFunction(ISerializationContext context, TwoArgStringFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__ARG1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_CALL__ARG1));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TWO_ARG_STRING_FUNCTION__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TWO_ARG_STRING_FUNCTION__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringFunctionAccess().getNameStringConcatKeyword_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStringFunctionAccess().getArg1ExpressionParserRuleCall_1_3_0(), semanticObject.getArg1());
		feeder.accept(grammarAccess.getStringFunctionAccess().getArg2ExpressionParserRuleCall_1_5_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Timevalue returns TimevalueInt
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Timevalue(ISerializationContext context, TimevalueInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TIMEVALUE_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TIMEVALUE_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimevalueAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Timevalue returns TimevalueVariable
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_Timevalue(ISerializationContext context, TimevalueVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TIMEVALUE_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TIMEVALUE_VARIABLE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimevalueAccess().getVariableVariableDotExpressionParserRuleCall_1_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDotExpression returns VariableDotExpression
	 *     VariableDotExpression.VariableDotExpression_1_0 returns VariableDotExpression
	 *
	 * Constraint:
	 *     (ref=VariableDotExpression_VariableDotExpression_1_0 tail=ID)
	 * </pre>
	 */
	protected void sequence_VariableDotExpression(ISerializationContext context, VariableDotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_DOT_EXPRESSION__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_DOT_EXPRESSION__REF));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_DOT_EXPRESSION__TAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_DOT_EXPRESSION__TAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDotExpressionAccess().getVariableDotExpressionRefAction_1_0(), semanticObject.getRef());
		feeder.accept(grammarAccess.getVariableDotExpressionAccess().getTailIDTerminalRuleCall_1_2_0(), semanticObject.getTail());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns VariableEvent
	 *     VariableEvent returns VariableEvent
	 *
	 * Constraint:
	 *     variable=VariableDotExpression
	 * </pre>
	 */
	protected void sequence_VariableEvent(ISerializationContext context, VariableEvent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_EVENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_EVENT__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableEventAccess().getVariableVariableDotExpressionParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableDotExpression returns VariableRef
	 *     VariableDotExpression.VariableDotExpression_1_0 returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=ID
	 * </pre>
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
}
