/*
 * generated by Xtext 2.27.0
 */
package org.xtext.example.mydsl.generator

import org.xtext.example.mydsl.myDsl.Proposition
import org.xtext.example.mydsl.myDsl.POr
import org.xtext.example.mydsl.myDsl.PAnd
import org.xtext.example.mydsl.myDsl.PEquality
import org.xtext.example.mydsl.myDsl.PComparison
import org.xtext.example.mydsl.myDsl.PAtomRecursive
import org.xtext.example.mydsl.myDsl.NegatedPAtom
import org.xtext.example.mydsl.myDsl.PAtomPredicate
//import org.xtext.example.mydsl.myDsl.PAtomEnum
import org.xtext.example.mydsl.myDsl.PAtomVariable
import org.xtext.example.mydsl.myDsl.PAtomPredicateTrueLiteral
import org.xtext.example.mydsl.myDsl.PAtomPredicateFalseLiteral
import org.xtext.example.mydsl.myDsl.PAtomDoubleLiteral
import org.xtext.example.mydsl.myDsl.PAtomIntLiteral
import org.xtext.example.mydsl.myDsl.PAtomDateLiteral
import org.xtext.example.mydsl.myDsl.PAtomStringLiteral
import org.xtext.example.mydsl.myDsl.PredicateFunctionHappens
import org.xtext.example.mydsl.myDsl.PredicateFunctionHappensAfter
import org.xtext.example.mydsl.myDsl.PredicateFunctionWHappensBefore
import org.xtext.example.mydsl.myDsl.PredicateFunctionSHappensBefore
import org.xtext.example.mydsl.myDsl.PredicateFunctionHappensWithin
import org.xtext.example.mydsl.myDsl.VariableEvent
import org.xtext.example.mydsl.myDsl.PowerEvent
import org.xtext.example.mydsl.myDsl.ContractEvent
import org.xtext.example.mydsl.myDsl.ObligationEvent
import org.xtext.example.mydsl.myDsl.Event
import org.xtext.example.mydsl.myDsl.VariableDotExpression
import java.util.ArrayList
import org.xtext.example.mydsl.myDsl.PredicateFunction
import org.xtext.example.mydsl.myDsl.PointFunction
import org.xtext.example.mydsl.myDsl.PointAtomParameterDotExpression
import org.xtext.example.mydsl.myDsl.PointAtomObligationEvent
import org.xtext.example.mydsl.myDsl.PointAtomPowerEvent
import org.xtext.example.mydsl.myDsl.PointAtomContractEvent
import org.xtext.example.mydsl.myDsl.Ref
import org.xtext.example.mydsl.myDsl.VariableRef
import org.xtext.example.mydsl.myDsl.PointExpression
import org.xtext.example.mydsl.myDsl.Timevalue
import org.xtext.example.mydsl.myDsl.TimevalueInt
import org.xtext.example.mydsl.myDsl.TimevalueVariable
import org.xtext.example.mydsl.myDsl.IntervalFunction
import org.xtext.example.mydsl.myDsl.SituationExpression
import org.xtext.example.mydsl.myDsl.ObligationState
import org.xtext.example.mydsl.myDsl.PowerState
import org.xtext.example.mydsl.myDsl.ContractState
import org.xtext.example.mydsl.myDsl.IntervalExpression
import org.xtext.example.mydsl.myDsl.PAtomFunction
import org.xtext.example.mydsl.myDsl.PredicateFunctionIsEqual
import org.xtext.example.mydsl.myDsl.PredicateFunctionIsOwner
import org.xtext.example.mydsl.myDsl.PredicateFunctionCannotBeAssigned
import org.xtext.example.mydsl.myDsl.PredicateFunctionWHappensBeforeEvent
import org.xtext.example.mydsl.myDsl.PredicateFunctionSHappensBeforeEvent
import org.xtext.example.mydsl.myDsl.PredicateFunctionOccurs
import org.xtext.example.mydsl.myDsl.Situation
import org.xtext.example.mydsl.myDsl.Interval
import org.xtext.example.mydsl.myDsl.OtherFunction
import org.xtext.example.mydsl.myDsl.PowerFunction
import org.xtext.example.mydsl.myDsl.PFObligationSuspended
import org.xtext.example.mydsl.myDsl.PFObligationResumed
import org.xtext.example.mydsl.myDsl.PFObligationDischarged
import org.xtext.example.mydsl.myDsl.PFObligationTerminated
import org.xtext.example.mydsl.myDsl.PFObligationTriggered
import org.xtext.example.mydsl.myDsl.PFContractSuspended
import org.xtext.example.mydsl.myDsl.PFContractResumed
import org.xtext.example.mydsl.myDsl.PFContractTerminated
import org.xtext.example.mydsl.myDsl.Expression
import org.xtext.example.mydsl.myDsl.Or
import org.xtext.example.mydsl.myDsl.And
import org.xtext.example.mydsl.myDsl.Equality
import org.xtext.example.mydsl.myDsl.Comparison
import org.xtext.example.mydsl.myDsl.Plus
import org.xtext.example.mydsl.myDsl.Minus
import org.xtext.example.mydsl.myDsl.Multi
import org.xtext.example.mydsl.myDsl.Div
import org.xtext.example.mydsl.myDsl.PrimaryExpressionRecursive
import org.xtext.example.mydsl.myDsl.PrimaryExpressionFunctionCall
import org.xtext.example.mydsl.myDsl.NegatedPrimaryExpression
import org.xtext.example.mydsl.myDsl.AtomicExpressionTrue
import org.xtext.example.mydsl.myDsl.AtomicExpressionFalse
import org.xtext.example.mydsl.myDsl.AtomicExpressionDouble
import org.xtext.example.mydsl.myDsl.AtomicExpressionInt
import org.xtext.example.mydsl.myDsl.AtomicExpressionDate
import org.xtext.example.mydsl.myDsl.AtomicExpressionString
import org.xtext.example.mydsl.myDsl.AtomicExpressionParameter
import org.xtext.example.mydsl.myDsl.TwoArgMathFunction
import org.xtext.example.mydsl.myDsl.OneArgMathFunction
import org.xtext.example.mydsl.myDsl.ThreeArgStringFunction
import org.xtext.example.mydsl.myDsl.TwoArgStringFunction
import org.xtext.example.mydsl.myDsl.OneArgStringFunction
import org.xtext.example.mydsl.myDsl.ThreeArgDateFunction
import org.xtext.example.mydsl.myDsl.AtomicExpressionEnum
import org.xtext.example.mydsl.myDsl.PAtomEnum

class SymboleoParser {
	def SymboleoParser() {
		
	}
	
  def String generateDotExpressionString(Ref argRef, String thisString) {
    val ids = new ArrayList<String>()
    var ref = argRef
    while (ref instanceof VariableDotExpression) {
      ids.add((ref as VariableDotExpression).tail)
      ref = (ref as VariableDotExpression).ref
    }
    if (ref instanceof VariableRef) {
      ids.add((ref as VariableRef).variable)
    }
    ids.add(thisString)
    
    for(id : ids) {
      if(id === "request") {
        ids.remove(id)
      }
    }
    
    return ids.reverse().join(".").substring(1)
  }
  
  def String generateEventVariableString(Event event) {
    switch (event) {
      VariableEvent: return generateDotExpressionString(event.variable, '')
      PowerEvent: return '''«event.eventName»(powers.«event.powerVariable.name»)'''
      ObligationEvent: return '''«event.eventName»(obligations.«event.obligationVariable.name»)'''
      ContractEvent: return '''«event.eventName»(self)'''
    }
  }
  
  //done
  def String generateTimeValueString(Timevalue tv) {
    switch (tv) {
      TimevalueInt: return tv.value.toString
      TimevalueVariable: return generateDotExpressionString(tv.variable, '')
    }
  }
  
  //done
//  def String generatePointExpresionString(PointExpression point) {
//    switch (point) {
//      PointFunction: return '''«point.name»(«generatePointExpresionString(point.arg)», «generateTimeValueString(point.value)», «point.timeUnit»)'''
//      PointAtomParameterDotExpression: {
//         return generateDotExpressionString(point.variable, '')
//      }
//      PointAtomObligationEvent: {
//        return generateEventVariableString(point.obligationEvent)
//      }
//      PointAtomPowerEvent: {
//      	return generateEventVariableString(point.powerEvent)
//      }
//      PointAtomContractEvent: {
//      	return generateEventVariableString(point.contractEvent)
//      }
//    }
//  }
  
  def String generatePointExpresionString(PointExpression point) {
    switch (point) {
      PointFunction: return '''«point.name»(«generatePointExpresionString(point.arg)», «generateTimeValueString(point.value)», «point.timeUnit»)'''
      PointAtomParameterDotExpression: return '''«generateDotExpressionString(point.variable, '')»'''
      
      PointAtomObligationEvent: {
        val e = point.obligationEvent as ObligationEvent        
        return '''«e.eventName»(obligations.«e.obligationVariable.name»)'''
      }
      PointAtomContractEvent: {
        val e = point.contractEvent as ContractEvent
        return '''«e.eventName»(self)'''
      }
      PointAtomPowerEvent: {
        val e = point.powerEvent as PowerEvent
        return '''«e.eventName»(powers.«e.powerVariable.name»)'''
      }

    }
  }
  
  //done
  def String generateIntervalExpresionArgString(IntervalExpression interval) {
    switch (interval) {
      IntervalFunction:
        return '''Interval(«generatePointExpresionString(interval.arg1)», «generatePointExpresionString(interval.arg2)»)'''
      SituationExpression: generateSituation(interval.situation)
	}
  }
  
  //done
  def String generateSituation(Situation situation) {
  	switch(situation) {
  	  ObligationState: return '''«situation.stateName»(obligations.«situation.obligationVariable.name»)'''
  	  PowerState: return '''«situation.stateName»(powers.«situation.powerVariable.name»)'''
  	  ContractState: return '''«situation.stateName»(self)'''
  	}
  }
  //done
  def String generatePredicateFunctionString(PredicateFunction predicate) {
    switch (predicate) {
      PredicateFunctionHappens: return '''Happens(«generateEventVariableString(predicate.event)»)'''
      PredicateFunctionWHappensBefore: return '''WhappensBefore(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionSHappensBefore: return '''ShappensBefore(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionHappensWithin: return '''HappensWithin(«generateEventVariableString(predicate.event)», «generateIntervalExpresionArgString(predicate.interval.intervalExpression)»)'''
      PredicateFunctionWHappensBeforeEvent: return '''WhappensBeforeE(«generateEventVariableString(predicate.event1)», «generateEventVariableString(predicate.event2)»'''
      PredicateFunctionSHappensBeforeEvent: return '''ShappensBeforeE(«generateEventVariableString(predicate.event1)», «generateEventVariableString(predicate.event2)»'''
      PredicateFunctionHappensAfter: return '''HappensAfter(«generateEventVariableString(predicate.event)», «generatePointExpresionString(predicate.point.pointExpression)»)'''
      PredicateFunctionOccurs: return '''Occurs(«generateSituation(predicate.situation)», «generateIntervalExpresionArgString(predicate.interval.intervalExpression)»)'''
    }
  }
  //done
  def String generateOtherFunction(OtherFunction func) {
  	switch(func){
  	  PredicateFunctionIsEqual:
  	  	return 'IsEqual(' + func.arg1 + ', ' + func.arg2 + ')'
  	  PredicateFunctionIsOwner:
  	  	return 'IsOwner(' + func.arg1 + ', ' + func.arg2 + ')'
  	  PredicateFunctionCannotBeAssigned:
  	  	return 'CannotBeAssigned(' + func.arg1 + ')'
  	}
  }
	
  def String generatePropositionString(Proposition proposition) {
    switch (proposition) {
      POr:
        return generatePropositionString(proposition.left) + " or " + generatePropositionString(proposition.right)
      PAnd:
        return generatePropositionString(proposition.left) + " and " + generatePropositionString(proposition.right)
      PEquality:
        return generatePropositionString(proposition.left) + proposition.op +
          generatePropositionString(proposition.right)
      PComparison:
        return generatePropositionString(proposition.left) + proposition.op +
          generatePropositionString(proposition.right)
      PAtomRecursive:
        return "(" + generatePropositionString(proposition.inner) + ")"
      NegatedPAtom:
        return "not(" + generatePropositionString(proposition.negated) + ")"
      PAtomPredicate:
        return generatePredicateFunctionString(proposition.predicateFunction)
      PAtomFunction:
      	return generateOtherFunction(proposition.function)
      PAtomEnum:
        return proposition.enumeration + "(" + proposition.enumItem + ")"
      PAtomVariable:
        return generateDotExpressionString(proposition.variable, '')
      PAtomPredicateTrueLiteral:
        return "true"
      PAtomPredicateFalseLiteral:
        return "false"
      PAtomDoubleLiteral:
        return proposition.value.toString
      PAtomIntLiteral:
        return proposition.value.toString
      PAtomDateLiteral:
        return '''Date("«proposition.value.toInstant.toString»")'''
      PAtomStringLiteral:
        return proposition.value
    }
  }
  
  def String generatePowerAction(PowerFunction pf) {
  	switch(pf) {
  	  PFObligationSuspended:
  		return 	'Suspended(obligations.' + pf.norm.name + ')'
  	
  	  PFObligationResumed:
  	  	return 	'Resumed(obligations.' + pf.norm.name + ')'
  	  	
  	  PFObligationDischarged:
  	  	return 	'Discharged(obligations.' + pf.norm.name + ')'
  	  	
  	  PFObligationTerminated:
  	  	return 	'Terminated(obligations.' + pf.norm.name + ')'
  	  	
  	  PFObligationTriggered:
  	  	return 	'Triggered(obligations.' + pf.norm.name + ')'
  	
  	  PFContractSuspended:
  	  	return 'Suspended(self)'
  	  	
   	  PFContractResumed:
  	  	return 'Resumed(self)'
  	  	
   	  PFContractTerminated:
  	  	return 'Terminated(self)'
  	}
  }
  
   def String generateFunctionCall(PrimaryExpressionFunctionCall argFunctionCallExp, String thisString) {
    val functionCall = argFunctionCallExp.function
    switch (functionCall) {
      TwoArgMathFunction:
        return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
          generateExpressionString(functionCall.arg2, thisString) + ")"
      OneArgMathFunction:
        return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
      ThreeArgStringFunction:
        return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
          generateExpressionString(functionCall.arg2, thisString) + "," + generateExpressionString(functionCall.arg3, thisString) + ")"
      TwoArgStringFunction:
        return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
          generateExpressionString(functionCall.arg2, thisString) + ")"
      OneArgStringFunction:
        return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
      ThreeArgDateFunction:
        return '''Date.add(«generateExpressionString(functionCall.arg1, thisString)», «generateExpressionString(functionCall.value, thisString)», «functionCall.timeUnit»)'''
    }
  }
  
  def String generateExpressionString(Expression argExpression, String thisString) {
    switch (argExpression) {
      Or:
        return generateExpressionString(argExpression.left, thisString) + " or " +
          generateExpressionString(argExpression.right, thisString)
      And:
        return generateExpressionString(argExpression.left, thisString) + " and " +
          generateExpressionString(argExpression.right, thisString)
      Equality:
        return generateExpressionString(argExpression.left, thisString) + argExpression.op +
          generateExpressionString(argExpression.right, thisString)
      Comparison:
        return generateExpressionString(argExpression.left, thisString) + argExpression.op +
          generateExpressionString(argExpression.right, thisString)
      Plus:
        return generateExpressionString(argExpression.left, thisString) + " + " +
          generateExpressionString(argExpression.right, thisString)
      Minus:
        return generateExpressionString(argExpression.left, thisString) + " - " +
          generateExpressionString(argExpression.right, thisString)
      Multi:
        return generateExpressionString(argExpression.left, thisString) + " * " +
          generateExpressionString(argExpression.right, thisString)
      Div:
        return generateExpressionString(argExpression.left, thisString) + " / " +
          generateExpressionString(argExpression.right, thisString)
      PrimaryExpressionRecursive:
        return "(" + generateExpressionString(argExpression.inner, thisString) + ")"
      PrimaryExpressionFunctionCall:
        return generateFunctionCall(argExpression, thisString)
      NegatedPrimaryExpression:
        return "not (" + generateExpressionString(argExpression.expression, thisString) + ")"
      AtomicExpressionTrue:
        return "true"
      AtomicExpressionFalse:
        return "false"
      AtomicExpressionDouble:
        return argExpression.value.toString()
      AtomicExpressionInt:
        return argExpression.value.toString()
      AtomicExpressionDate:
        return '''Date("«argExpression.value.toInstant.toString»")'''
      AtomicExpressionEnum:
        return argExpression.enumeration + "(" + argExpression.enumItem + ")"
      AtomicExpressionString:
        return '"' + argExpression.value + '"'
      AtomicExpressionParameter:
        return generateDotExpressionString(argExpression.value, thisString)
    }
  }
  
}